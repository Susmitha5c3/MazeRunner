{"ast":null,"code":"import _createForOfIteratorHelper from\"/home/susmitha/pathfinding-visualizer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid,startNode,finishNode){var visitedNodesInOrder=[];startNode.distance=0;var unvisitedNodes=getAllNodes(grid);while(!!unvisitedNodes.length){sortNodesByDistance(unvisitedNodes);var closestNode=unvisitedNodes.shift();// If we encounter a wall, we skip it.\nif(closestNode.isWall)continue;// If the closest node is at a distance of infinity,\n// we must be trapped and should therefore stop.\nif(closestNode.distance===Infinity)return visitedNodesInOrder;closestNode.isVisited=true;visitedNodesInOrder.push(closestNode);if(closestNode===finishNode)return visitedNodesInOrder;updateUnvisitedNeighbors(closestNode,grid);}}function sortNodesByDistance(unvisitedNodes){unvisitedNodes.sort(function(nodeA,nodeB){return nodeA.distance-nodeB.distance;});}function updateUnvisitedNeighbors(node,grid){var unvisitedNeighbors=getUnvisitedNeighbors(node,grid);var _iterator=_createForOfIteratorHelper(unvisitedNeighbors),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbor=_step.value;neighbor.distance=node.distance+1;neighbor.previousNode=node;}}catch(err){_iterator.e(err);}finally{_iterator.f();}}function getUnvisitedNeighbors(node,grid){var neighbors=[];var col=node.col,row=node.row;if(row>0)neighbors.push(grid[row-1][col]);if(row<grid.length-1)neighbors.push(grid[row+1][col]);if(col>0)neighbors.push(grid[row][col-1]);if(col<grid[0].length-1)neighbors.push(grid[row][col+1]);return neighbors.filter(function(neighbor){return!neighbor.isVisited;});}function getAllNodes(grid){var nodes=[];var _iterator2=_createForOfIteratorHelper(grid),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var row=_step2.value;var _iterator3=_createForOfIteratorHelper(row),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var node=_step3.value;nodes.push(node);}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return nodes;}// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode){var nodesInShortestPathOrder=[];var currentNode=finishNode;while(currentNode!==null){nodesInShortestPathOrder.unshift(currentNode);currentNode=currentNode.previousNode;}return nodesInShortestPathOrder;}","map":{"version":3,"sources":["/home/susmitha/pathfinding-visualizer/src/algorithms/dijkstra.js"],"names":["dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","getAllNodes","length","sortNodesByDistance","closestNode","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbors","sort","nodeA","nodeB","node","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","col","row","filter","nodes","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift"],"mappings":"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","sourcesContent":["// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    const unvisitedNodes = getAllNodes(grid);\n    while (!!unvisitedNodes.length) {\n      sortNodesByDistance(unvisitedNodes);\n      const closestNode = unvisitedNodes.shift();\n      // If we encounter a wall, we skip it.\n      if (closestNode.isWall) continue;\n      // If the closest node is at a distance of infinity,\n      // we must be trapped and should therefore stop.\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n      if (closestNode === finishNode) return visitedNodesInOrder;\n      updateUnvisitedNeighbors(closestNode, grid);\n    }\n  }\n  \n  function sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n  }\n  \n  function updateUnvisitedNeighbors(node, grid) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      neighbor.distance = node.distance + 1;\n      neighbor.previousNode = node;\n    }\n  }\n  \n  function getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n  }\n  \n  function getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n  }\n  \n  // Backtracks from the finishNode to find the shortest path.\n  // Only works when called *after* the dijkstra method above.\n  export function getNodesInShortestPathOrder(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }"]},"metadata":{},"sourceType":"module"}